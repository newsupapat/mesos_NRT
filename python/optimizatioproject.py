# -*- coding: utf-8 -*-
"""OptimizatioProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R0J6J0ZjVY2B7Xyyp7SlCMZLI63PDi2C
"""

NVARS = 1
GENERATIONS = 1000
NPOP = 100
steps = 100
limitbudget = 700000

import math
import time
from numpy import pi
import matplotlib.pyplot as plt
from matplotlib import cm 
import numpy as np
import random
import tracemalloc
import psutil

tracemalloc.start()

def get_cpu_usage_pct():
    """
    Obtains the system's average CPU load as measured over a period of 500 milliseconds.
    :returns: System CPU load as a percentage.
    :rtype: float
    """
    return psutil.cpu_percent(interval=1)

def plotContour(problem, xmin, xmax, dots=100):
    fig = plt.figure()
    ax = plt.axes()
    
    x1 = np.linspace(xmin[0], xmax[0], dots)
    x2 = np.linspace(xmin[1], xmax[1], 100)
    X1, X2 = np.meshgrid(x1, x2)
    Y = np.copy(X1)
    for i in range(0, X1.shape[0]):
        for j in range(0, X1.shape[1]):
            Y[i, j] = problem.evaluate( (X1[i, j], X2[i, j]) )[0]  # notice        
    surf = ax.contourf(X1, X2, Y, 100, cmap='RdGy') #cmap=cm.coolwarm)
    fig.colorbar(surf, shrink=0.5, aspect=5)
    plt.show()
    return plt
  
def plotLine(plt, a, b, color="red"):
    plt.plot( [a[0], b[0]], [a[1], b[1]], color)

def fitness_evaluate(population):
    # 1 คือ Lychee , 2 คือ Rambutan, 3 คือ Grapefruit
    profit = {"1": 14745.53, "2" : 44958.94,"3" : 89325.55}
    rai=[15,30,25,40,10,50,20,10,30,68,18,72,13,72,49,80]
    return (rai[0] * profit[population[0][0]] + rai[1] * profit[population[0][1]] + rai[2] * profit[population[0][2]] +
    rai[3] * profit[population[0][3]] + rai[4] * profit[population[0][4]]  + rai[5] * profit[population[0][5]] +
    rai[6] * profit[population[0][6]] + rai[7] * profit[population[0][7]] + rai[8] * profit[population[0][8]] + 
    rai[9] * profit[population[0][9]] + rai[10] * profit[population[0][10]] + rai[11] * profit[population[0][11]] +
    rai[12] * profit[population[0][12]] + rai[13] * profit[population[0][13]] + rai[14] * profit[population[0][14]])

def crossover(allpopulation):
    pair1 = random.randrange(0,100)
    pair2 = random.randrange(0,100)
    cpos = random.randrange(1,14)
    return allpopulation[pair1][0][0:cpos]  + allpopulation[pair2][0][cpos:15]

def mutation(population):
    pos = random.randrange(0,15)
    return population[0:pos] + str(random.randrange(1,4)) + population[pos+1:15]

def rand_key(p,npop):     
    key2 = []
    for i in range(npop):
        key1 = ""
        for i in range(p): 
            temp = str(random.randint(1, 3)) 
            key1 += temp       
        key2.append([key1,0])
    return(key2)

def rand_key_individual(p): 
    key1 = "" 
    for i in range(p): 
        temp = str(random.randint(1, 3)) 
        key1 += temp  
    return(key1)

def print_result(population):
  index1 = [i+1 for i, a in enumerate(population) if a == "1"]
  index2 = [i+1 for i, a in enumerate(population) if a == "2"]
  index3 = [i+1 for i, a in enumerate(population) if a == "3"]
  print("you have to plan Lychee at Land" ,index1)
  print("you have to plan Rambutan at Land" ,index2)
  print("you have to plan GrapeFruit at Land" ,index3)

def check_constraint(population):
  rai=[15,30,25,40,10,50,20,10,30,68,18,72,13,72,49,80]
  cost={"1": 997.03, "2" : 973.97,"3" : 1994.50}
  budget = (rai[0] * cost[population[0]] + rai[1] * cost[population[1]] + rai[2] * cost[population[2]] +
    rai[3] * cost[population[3]] + rai[4] * cost[population[4]]  + rai[5] * cost[population[5]] +
    rai[6] * cost[population[6]] + rai[7] * cost[population[7]] + rai[8] * cost[population[8]] + 
    rai[9] * cost[population[9]] + rai[10] * cost[population[10]] + rai[11] * cost[population[11]] +
    rai[12] * cost[population[12]] + rai[13] * cost[population[13]] + rai[14] * cost[population[14]])
  index1 = [i for i, a in enumerate(population) if a == "1"]
  index2 = [i for i, a in enumerate(population) if a == "2"]
  product1 = 0
  product2 = 0
  for i in index1:
    product1 = product1 + rai[i] * 499.13
  for i in index2:
    product2 = product2 + rai[i] * 1816.88
  if product1 <= 50000 or product2 <= 30000 or budget > limitbudget:
    return True
  else:
    return False

def ga(nvars, generations, npop):
    bestID = 0
    bests = np.zeros([steps ** NVARS, NVARS+1])       # each row [X fitness]
    pop = np.zeros([npop, NVARS+1])
    x = rand_key(15,npop)
    for i in range(generations):
        fitness=[]
        for population in x:
                   fitness.append([population[0],float(fitness_evaluate(population))])
        fitness.sort(key = lambda item: item[1], reverse = True)
        if bestID == 0 or fitness[0][1] > bests[bestID - 1,-1]:
            bests[bestID,:] = [fitness[0][0],fitness[0][1]]
            bestID = bestID + 1
        for index,populationfitness in enumerate(fitness):
          if index>=10 and index<=89:
              prob = random.randrange(1,101)
              if(prob > 5):
                 prob = random.randrange(1,101)
                 if(prob<=80):
                 #crossover
                    fitness[index][0]=crossover(fitness)
                 prob = random.randrange(1,101)
                 if(prob<=10):
                  #mutation
                   fitness[index][0]=mutation(fitness[index][0])
          elif index >= 90:
              fitness[index][0] = rand_key_individual(15)
        x=fitness
    return bests[0:bestID, :]

stime = time.time()
bests = ga(NVARS, GENERATIONS, NPOP)
print("Time used: %.0f seconds" % ( time.time() - stime))
print("The best profit is: ", bests[-1][1])
print_result(str(int(bests[-1][0])))

def gawithconstraint(nvars, generations, npop):
    bestID = 0
    bests = np.zeros([steps ** NVARS, NVARS+1])       # each row [X fitness]
    pop = np.zeros([npop, NVARS+1])
    x = rand_key(15,npop)
    for i in range(generations):
        fitness=[]
        for population in x:
                   while (check_constraint(population[0])):
                       population[0] = rand_key_individual(15)
                   fitness.append([population[0],float(fitness_evaluate(population))])
        fitness.sort(key = lambda item: item[1], reverse = True)
        if bestID == 0 or fitness[0][1] > bests[bestID - 1,-1]:
            bests[bestID,:] = [fitness[0][0],fitness[0][1]]
            bestID = bestID + 1
        for index,populationfitness in enumerate(fitness):

          if index>=10 and index<=89:
              prob = random.randrange(1,101)
              if(prob > 5):
                 prob = random.randrange(1,101)
                 if(prob<=80):
                 #crossover
                    fitness[index][0]=crossover(fitness)
                 prob = random.randrange(1,101)
                 if(prob<=10):
                  #mutation
                   fitness[index][0]=mutation(fitness[index][0])
          elif index >= 90:
              fitness[index][0] = rand_key_individual(15)
        x=fitness
    return bests[0:bestID, :]

stime = time.time()
bests = gawithconstraint(NVARS, GENERATIONS, NPOP)
print("Time used: %.0f seconds" % ( time.time() - stime))
print("The best profit is: ", bests[-1][1] , "baht")
print_result(str(int(bests[-1][0])))

def gawithconstraintpenalty(nvars, generations, npop):
    bestID = 0
    bests = np.zeros([steps ** NVARS, NVARS+1])       # each row [X fitness]
    pop = np.zeros([npop, NVARS+1])
    x = rand_key(15,npop)
    for i in range(generations):
        fitness=[]
        for population in x:
          if check_constraint(population[0]):
                   fitness.append([population[0],-1])
          else:
                   fitness.append([population[0],float(fitness_evaluate(population))])
        fitness.sort(key = lambda item: item[1], reverse = True)
        if bestID == 0 or fitness[0][1] > bests[bestID - 1,-1]:
            bests[bestID,:] = [fitness[0][0],fitness[0][1]]
            bestID = bestID + 1
        for index,populationfitness in enumerate(fitness):
          if index>=10 and index<=89:
              prob = random.randrange(1,101)
              if(prob > 5):
                 prob = random.randrange(1,101)
                 if(prob<=80):
                 #crossover
                    fitness[index][0]=crossover(fitness)
                 prob = random.randrange(1,101)
                 if(prob<=10):
                  #mutation
                   fitness[index][0]=mutation(fitness[index][0])
          elif index >= 90:
              fitness[index][0] = rand_key_individual(15)
        x=fitness
    return bests[0:bestID, :]
stime = time.time()
bests = gawithconstraintpenalty(NVARS, GENERATIONS, NPOP)
print("Time used: %.0f seconds" % ( time.time() - stime))
print("The best profit is: ", bests[-1][1] , "baht")
print_result(str(int(bests[-1][0])))
current, peak = tracemalloc.get_traced_memory()
print(f"Current memory usage is {current / 10**6}MB; Peak was {peak / 10**6}MB")
tracemalloc.stop()
print('System CPU load is {} %'.format(get_cpu_usage_pct()))